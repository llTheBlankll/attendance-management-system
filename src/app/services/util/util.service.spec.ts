import {TestBed} from '@angular/core/testing';

import {UtilService} from './util.service';
import {DateRange} from "../../interfaces/DateRange";

describe('UtilService', () => {
  let service: UtilService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(UtilService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  // Generated by CodiumAI

  describe('dateToTimestamp', () => {

    // Converts a single Date object to a Timestamp range for the entire day
    it('should convert Date object to Timestamp range for the entire day', () => {
      // Given
      const utilService = new UtilService();
      const date = new Date(2023, 9, 10);

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(date);

      // Then
      expect(startTimestamp.toDate()).toEqual(new Date(2023, 9, 10, 0, 0, 0));
      expect(endTimestamp.toDate()).toEqual(new Date(2023, 9, 10, 23, 59, 59));
    });

    // Converts a DateRange object to a Timestamp range from start to end date
    it('should convert DateRange object to Timestamp range from start to end date', () => {
      // Given
      const utilService = new UtilService();
      const dateRange = new DateRange(new Date(2023, 9, 10), new Date(2023, 9, 12));

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(dateRange);

      // Then
      expect(startTimestamp.toDate()).toEqual(new Date(2023, 9, 10, 0, 0, 0, 999));
      expect(endTimestamp.toDate()).toEqual(new Date(2023, 9, 12, 23, 59, 59, 999));
    });

    // Correctly sets start time to 00:00:00 and end time to 23:59:59 for Date input
    it('should set start time to 00:00:00 and end time to 23:59:59 for Date input', () => {
      // Given
      const utilService = new UtilService();
      const date = new Date(2023, 9, 10);

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(date);

      // Then
      expect(startTimestamp.toDate().getHours()).toEqual(0);
      expect(startTimestamp.toDate().getMinutes()).toEqual(0);
      expect(startTimestamp.toDate().getSeconds()).toEqual(0);
      expect(endTimestamp.toDate().getHours()).toEqual(23);
      expect(endTimestamp.toDate().getMinutes()).toEqual(59);
      expect(endTimestamp.toDate().getSeconds()).toEqual(59);
    });

    // Correctly sets start time to 00:00:00 and end time to 23:59:59 for DateRange input
    it('should set start time to 00:00:00 and end time to 23:59:59 for DateRange input', () => {
      // Given
      const utilService = new UtilService();
      const dateRange = new DateRange(new Date(2023, 9, 10), new Date(2023, 9, 12));

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(dateRange);

      // Then
      expect(startTimestamp.toDate().getUTCHours()).toEqual(0);
      expect(startTimestamp.toDate().getUTCMinutes()).toEqual(0);
      expect(startTimestamp.toDate().getUTCSeconds()).toEqual(0);
      expect(endTimestamp.toDate().getUTCHours()).toEqual(23);
      expect(endTimestamp.toDate().getUTCMinutes()).toEqual(59);
      expect(endTimestamp.toDate().getUTCSeconds()).toEqual(59);
    });

    // Handles invalid Date object input gracefully
    it('should handle invalid Date object input gracefully', () => {
      // Given
      const utilService = new UtilService();
      const invalidDate = new Date('invalid-date');

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(invalidDate);

      // Then
      expect(startTimestamp).toBeNull();
      expect(endTimestamp).toBeNull();
    });

    // Handles invalid DateRange object input gracefully
    it('should handle invalid DateRange object input gracefully', () => {
      // Given
      const utilService = new UtilService();
      const invalidDateRange = new DateRange(new Date('invalid-date'), new Date('invalid-date'));

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(invalidDateRange);

      // Then
      expect(startTimestamp).toBeNull();
      expect(endTimestamp).toBeNull();
    });

    // Handles Date object with different timezones correctly
    it('should handle Date object with different timezones correctly', () => {
      // Given
      const utilService = new UtilService();
      const date = new Date('2023-10-10T12:00:00Z'); // UTC date

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(date);

      // Then
      expect(startTimestamp.toDate().getUTCHours()).toEqual(0);
      expect(startTimestamp.toDate().getUTCMinutes()).toEqual(0);
      expect(startTimestamp.toDate().getUTCSeconds()).toEqual(0);
      expect(endTimestamp.toDate().getUTCHours()).toEqual(23);
      expect(endTimestamp.toDate().getUTCMinutes()).toEqual(59);
      expect(endTimestamp.toDate().getUTCSeconds()).toEqual(59);
    });

    // Handles DateRange object with different timezones correctly
    it('should handle DateRange object with different timezones correctly', () => {
      // Given
      const utilService = new UtilService();
      const dateRange = new DateRange(new Date('2023-10-10T12:00:00Z'), new Date('2023-10-12T12:00:00Z')); // UTC dates

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(dateRange);

      // Then
      expect(startTimestamp.toDate().getUTCHours()).toEqual(0);
      expect(startTimestamp.toDate().getUTCMinutes()).toEqual(0);
      expect(startTimestamp.toDate().getUTCSeconds()).toEqual(0);
      expect(endTimestamp.toDate().getUTCHours()).toEqual(23);
      expect(endTimestamp.toDate().getUTCMinutes()).toEqual(59);
      expect(endTimestamp.toDate().getUTCSeconds()).toEqual(59);
    });

    // Handles DateRange where startDate is after endDate
    it('should handle DateRange where startDate is after endDate correctly', () => {
      // Given
      const utilService = new UtilService();
      const dateRange = new DateRange(new Date(2023, 9, 12), new Date(2023, 9, 10));

      // When
      const [startTimestamp, endTimestamp] = utilService.dateToTimestamp(dateRange);

      // Then
      expect(startTimestamp).toBeNull();
      expect(endTimestamp).toBeNull();
    });
  });

});
